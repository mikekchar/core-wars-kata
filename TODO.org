* Core Wars Kata
  Boring day, but that happens.  This has been One Pomodoro a Day.
  Until next time!
** Burndown
*** Log events
**** DONE Log the death of warriors
     CLOSED: [2016-02-21 Sun 10:54]
     Going to keep it like that because I don't know what I want
     to do yet.
**** TODO Create shared context for setting up monitor
**** TODO Create a log object
**** TODO Log the creation of a new task in a warrior
**** TODO Log the end of a task in a warrior
** Backlog
*** Inspect running state of the memory
    Since this is a "retro" project, I thought it would be fun
    to implement the command set from the old Apple II
    machine language monitor
**** TODO [RETURN]
      Display up to 8 locations following the last opened location.
**** TODO {addr1}.{addr2}
      Inspect memory from addr1 to addr2
*** Set the state of the memory
**** TODO :{val}
     Sets a value starting at the next address from the one
     last accessed.
*** Loading Files
*** Ensure fair distribution of cache writes between warriors
    If there are 2 warriors, A and B, and A gets to write before
    B each time, then A will have an advantage.  Ideally we will
    randomly write the chache for all of the tasks.
*** Instruction tech tasks :-P
    I bet I never do this :-)
**** TODO Ensure that instructions are immutable
**** TODO Write matcher for instructions
*** Core options
**** TODO Specify Initial core size
**** TODO Specify Initial instruction to load into the whole core
**** TODO Specify that the core has the same state as last run
     Might have to save the state somehow
**** TODO Specify that the core has a random value

** Done
*** Setup
**** DONE Initial failing test
     CLOSED: [2015-11-12 Thu 13:38]
     I think I already did this.
**** DONE Look at the documentation for Core Wars.
     CLOSED: [2015-11-12 Thu 13:43]
     I added the spec to the doc directory.
     Aaarghh... it's HTML.  Let's open another window.
     Not sure if the documentation explains the virtual machine...
     It must somewhere.  Will need to look more closely.
     But I've seen enough to make a rough plan.
*** Interactive mode
**** DONE Add an executable
     CLOSED: [2015-11-16 Mon 12:58]
*** Build the memory core
**** DONE Make a stupid class
     CLOSED: [2015-11-12 Thu 13:53]
**** DONE It needs a size
     CLOSED: [2015-11-13 Fri 10:16]
**** DONE Store things in the memory
     CLOSED: [2015-11-16 Mon 09:42]
     I'm not terribly worried about the data size.  We will fix it
     later.
***** DONE Allocate memory
      CLOSED: [2015-11-16 Mon 09:31]
***** DONE Determine if we should wrap on setting addresses
      CLOSED: [2015-11-16 Mon 09:42]
      i.e. should store(size+1) set the zeroth value?
      There appears to be a concept of "folding" that does this.
      I don't quite understand, but I will defer this until
      we implement addressing modes.
**** DONE accessing memory greater than size should access addr % size
     CLOSED: [2015-11-27 Fri 17:50]
     Good enough for now.  I will add more tests when I implement
     the maximum jump sizes, etc.
**** DONE accessing negative addr should index size - addr - 1
     CLOSED: [2015-11-27 Fri 17:50]
*** Interactive mode
**** DONE Add command switch to enter interactive mode
     CLOSED: [2015-11-17 Tue 14:49]
     No idea how to test drive this.  Let's not.
     WRITE TESTS!!!
     Good enough for now.
**** DONE Add a monitor that can take input
     CLOSED: [2015-11-18 Wed 13:12]
**** DONE Add interactive exit command
     CLOSED: [2015-11-19 Thu 14:26]
     I suppose ctl-D can also exit since it already does that
**** DONE Print error message for unknown commands
     CLOSED: [2015-11-19 Thu 14:43]
     You may have noticed that the Monitor code is sucky.
     I'm waiting until the right time to refactor it.
     Not sure when that will be...
**** DONE Hook up the bin!!!!
     CLOSED: [2015-11-20 Fri 13:53]
**** DONE Allow inputting negative addresses
     CLOSED: [2015-11-27 Fri 17:59]
**** DONE Finish refactoring Monitor::Command refactor
     CLOSED: [2015-12-02 Wed 04:38]
     Good enough for now.  I don't like how we are passing
     monitor around and how we need to build it for all of the
     monitor command tests, but it isn't horrible yet.
*** Inspect running state of the memory
**** DONE Create core at the start of the app
     CLOSED: [2015-11-20 Fri 14:08]
**** DONE {addr}
     CLOSED: [2015-11-21 Sat 14:05]
     Inspect one memory location
     I *did* forget something: to test if it works in process()
**** DONE addrs should be referenced in hexadecimal
     CLOSED: [2015-11-26 Thu 17:52]
     The spec doesn't say this, but that's how the Apple II
     monitor works.
**** DONE memory contents should be printed in hex digits
     CLOSED: [2015-11-26 Thu 18:05]
     Sigh... Not great, but it will do for now
     
**** DONE print address when outputting the memory
     CLOSED: [2015-12-24 Thu 01:41]
*** Set the state of the memory
**** DONE {addr}:{val}
     CLOSED: [2015-11-30 Mon 18:00]
     Sets the value at an address
     We left a failing test for this one
**** DONE Allow user to add DAT.F instructions to core
     CLOSED: [2015-12-16 Wed 12:49]
**** DONE Allow lower case and multiple spaces in DAT instruction
     CLOSED: [2015-12-20 Sun 06:05]
**** DONE Remove hexadecimal addressing from monitor
     CLOSED: [2015-12-20 Sun 06:15]
     The spec uses decimal, so it will just get confusing
**** DONE Give error message when mode or operands are incorrect
     CLOSED: [2015-12-31 Thu 02:48]
*** Implement DAT.F instruction
    An instruction is commposed of:
      - opcode
      - modifier
      - A operand
      - B operand
    Operands are composed of
      - mode
      - number
**** DONE Initialize core with DAT.F #0, #0
     CLOSED: [2015-12-13 Sun 00:47]
**** DONE Display instructions instead of integers in the core
     CLOSED: [2015-12-13 Sun 00:47]
**** DONE Allow the user to store a DAT.F #x, #y instruction
     CLOSED: [2015-12-20 Sun 06:17]
**** DONE Build operand more easily
     CLOSED: [2015-12-24 Thu 01:58]
     The code is littered with operand constructions.  It would
     be nice to just be able to construct them from a string.
**** DONE Build Dat instructions more easily
     CLOSED: [2015-12-25 Fri 07:23]
     Now write a build() method on Dat that allows the operands
     to be put in the constructor as a string.
**** DONE Allow negative numbers in the operand
     CLOSED: [2015-12-28 Mon 03:29]
**** DONE Remove Task from Task Queue when executed
     CLOSED: [2016-02-03 Wed 11:55]
      Display the number of remaining tasks in the task queue in
      the monitor.  If there are no tasks remaining in the queue
      remove the warrior and display a message in the monitor.

      Basically, I've already got a situation where the tail
      is wagging the dog: the task removes itself from its
      queue.  However, I don't really want the register to tell
      the task to remove itself from the queue.  Instead we
      will have a special flag on the register to say whether
      the task is alive or dead.
**** DONE Remove Warrior from warriors when it has no tasks
     CLOSED: [2016-02-04 Thu 12:11]
*** Add a warrior
**** DONE Display an empty list of warriors when e is pressed
      CLOSED: [2015-12-26 Sat 14:17]
*** Implement ADD.AB Instruction
**** DONE Add direct addressing mode
     CLOSED: [2015-12-28 Mon 03:34]
     Simply allow $ in the operand
**** DONE Store ADD.AB instruction via monitor
     CLOSED: [2015-12-30 Wed 08:50]
**** DONE Write the memory cache to the core
     CLOSED: [2016-01-29 Fri 11:33]
***** DONE Write tests for warrior
      CLOSED: [2016-01-29 Fri 11:33]
**** Direct Addressing Mode
    ADD.AB #4, $-1
    Adds 4 to the B operand of the address: PC - 1
***** DONE Fetch instruction into a memory cache
      CLOSED: [2016-01-18 Mon 12:00]
      It has been fetched into a register, but it still needs to be
      put into the cache.  Not really necessary for this instruction,
      but I think I will do it anyway.
***** DONE Fetch instruction pointed to by operand B into the memory cache
      CLOSED: [2016-01-20 Wed 09:52]
***** DONE Add operand A to the instruction in the memory cache
      CLOSED: [2016-01-22 Fri 12:58]
      It occurs to me that I have sufferred slightly from too much
      design up front.  You may be thinking, "What design???  You've been
      hacking every second."  However, it is important to try to keep
      and empty mind when starting each piece of code.
*** Add Step command
**** DONE Add a warrior when S command issued
     CLOSED: [2016-01-03 Sun 06:36]
     Format: 123S
             where 123 is the address
**** DONE Display the warrior after step command
     CLOSED: [2016-01-03 Sun 06:35]
     When the S command is first issued, display the Warrior including
     the task queue.  Each task (there will only be one at the moment)
     will have a program counter.  The warrior will only be
     displayed after the execution of the opcode.
**** DONE Add a Task to the Task Queue when stepping with an argument
     CLOSED: [2016-01-07 Thu 06:49]
     Each task contains a PC.  
***** DONE Write tests for TaskQueue
      CLOSED: [2016-01-07 Thu 06:48]
**** DONE It displays the task queue for each warrior when stepping
     CLOSED: [2016-01-12 Tue 09:29]
**** DONE S steps to the next PC address when there is no argument
     CLOSED: [2016-02-05 Fri 17:04]
     for each task in all warriors
*** Log events
**** DONE Log the creation of warriors
     CLOSED: [2016-02-09 Tue 14:11]
*** Bugs
**** DONE Bug: All memory locations are initialize with the same instruction
     CLOSED: [2016-01-22 Fri 13:03]
     as in the same object.  There should be a new one for each object.
**** DONE Bug: Cache fetches actual objects rather than copy
